Use this README file to introduce your application and point to useful places in the API for learning more.
Run "rake doc:app" to generate API documentation for your models, controllers, helpers, and libraries.




#How to create cucumber in rails 3

Before start cucumber change the environment to test

$sudo rake gem:install RAILS_ENV = test



step1. sudo gem install cucumber-rails
step2. sudo gem install database_cleaner
step3. sudo gem install rspec-rails
step4: Include all the above gem in GEMFIEL under group :test do
step5: bundle install
step5: rails g rspec:install
step6: rails g cucumber:install  --rspec --capybara 
add this line to cucumber.yml in config folder

std_opts = "--format #{ENV['CUCUMBER_FORMAT'] || 'pretty'} --strict --require features --tags ~@wip"


step7: rake cucumber
step8: Create a Cucumber Feature for Rails 3 application testing

       features/manage_articels.feature

        Feature: Manage Articles

		In order to make a blog
		As an author
		I want to create and mange articles


         Scenario: Articles List

		Given I have articles titled dhoni, sachin

		When I go to list of articles

		Then I should see "dhoni"
		
		And I should see "sachin"


step9: Test the Cucumber Features
       cucumber features/manage_articles.feature

step10:create steps for articles in step_definitions folder

        step_definiations/articles_steps.rb        
        
        Given /^I have articles titled (.+)$/ do |titles|
	  titles.split(', ').each do |title|
	    Article.create(:title=>title)
	  end
	end
step11: create web_steps.rb

	      # IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
	# It is recommended to regenerate this file in the future when you upgrade to a 
	# newer version of cucumber-rails. Consider adding your own code to a new file 
	# instead of editing this one. Cucumber will automatically load all features/**/*.rb
	# files.


	require 'uri'
	require 'cgi'
	require File.expand_path(File.join(File.dirname(__FILE__), "..", "support", "paths"))

	module WithinHelpers
	  def with_scope(locator)
	    locator ? within(locator) { yield } : yield
	  end
	   def path_to(page_name)
	    
	      case page_name
	      
	      when /the home page/
		roo_path
	       when /list of articles/
		articles_path
	   
	     #Add more name=>mapping here
	     else
		 raise "cant find mapping from \"#{page_name}\" to a path" 
	      end
	   end
	end
	World(WithinHelpers)

	Given /^(?:|I )am on (.+)$/ do |page_name|

	  visit path_to(page_name)
	end

	When /^(?:|I )go to (.+)$/ do |page_name|
	  visit path_to(page_name)
	end

	When /^(?:|I )press "([^"]*)"(?: within "([^"]*)")?$/ do |button, selector|
	  with_scope(selector) do
	    click_button(button)
	  end
	end

	When /^(?:|I )follow "([^"]*)"(?: within "([^"]*)")?$/ do |link, selector|
	  with_scope(selector) do
	    click_link(link)
	  end
	end

	When /^(?:|I )fill in "([^"]*)" with "([^"]*)"(?: within "([^"]*)")?$/ do |field, value, selector|
	  with_scope(selector) do
	    fill_in(field, :with => value)
	  end
	end

	When /^(?:|I )fill in "([^"]*)" for "([^"]*)"(?: within "([^"]*)")?$/ do |value, field, selector|
	  with_scope(selector) do
	    fill_in(field, :with => value)
	  end
	end

	# Use this to fill in an entire form with data from a table. Example:
	#
	#   When I fill in the following:
	#     | Account Number | 5002       |
	#     | Expiry date    | 2009-11-01 |
	#     | Note           | Nice guy   |
	#     | Wants Email?   |            |
	#
	# TODO: Add support for checkbox, select og option
	# based on naming conventions.
	#
	When /^(?:|I )fill in the following(?: within "([^"]*)")?:$/ do |selector, fields|
	  with_scope(selector) do
	    fields.rows_hash.each do |name, value|
	      When %{I fill in "#{name}" with "#{value}"}
	    end
	  end
	end

	When /^(?:|I )select "([^"]*)" from "([^"]*)"(?: within "([^"]*)")?$/ do |value, field, selector|
	  with_scope(selector) do
	    select(value, :from => field)
	  end
	end

	When /^(?:|I )check "([^"]*)"(?: within "([^"]*)")?$/ do |field, selector|
	  with_scope(selector) do
	    check(field)
	  end
	end

	When /^(?:|I )uncheck "([^"]*)"(?: within "([^"]*)")?$/ do |field, selector|
	  with_scope(selector) do
	    uncheck(field)
	  end
	end

	When /^(?:|I )choose "([^"]*)"(?: within "([^"]*)")?$/ do |field, selector|
	  with_scope(selector) do
	    choose(field)
	  end
	end

	When /^(?:|I )attach the file "([^"]*)" to "([^"]*)"(?: within "([^"]*)")?$/ do |path, field, selector|
	  with_scope(selector) do
	    attach_file(field, path)
	  end
	end

	Then /^(?:|I )should see JSON:$/ do |expected_json|
	  require 'json'
	  expected = JSON.pretty_generate(JSON.parse(expected_json))
	  actual   = JSON.pretty_generate(JSON.parse(response.body))
	  expected.should == actual
	end

	Then /^(?:|I )should see "([^"]*)"(?: within "([^"]*)")?$/ do |text, selector|
	  with_scope(selector) do
	    if page.respond_to? :should
	      page.should have_content(text)
	    else
	      assert page.has_content?(text)
	    end
	  end
	end

	Then /^(?:|I )should see \/([^\/]*)\/(?: within "([^"]*)")?$/ do |regexp, selector|
	  regexp = Regexp.new(regexp)
	  with_scope(selector) do
	    if page.respond_to? :should
	      page.should have_xpath('//*', :text => regexp)
	    else
	      assert page.has_xpath?('//*', :text => regexp)
	    end
	  end
	end

	Then /^(?:|I )should not see "([^"]*)"(?: within "([^"]*)")?$/ do |text, selector|
	  with_scope(selector) do
	    if page.respond_to? :should
	      page.should have_no_content(text)
	    else
	      assert page.has_no_content?(text)
	    end
	  end
	end

	Then /^(?:|I )should not see \/([^\/]*)\/(?: within "([^"]*)")?$/ do |regexp, selector|
	  regexp = Regexp.new(regexp)
	  with_scope(selector) do
	    if page.respond_to? :should
	      page.should have_no_xpath('//*', :text => regexp)
	    else
	      assert page.has_no_xpath?('//*', :text => regexp)
	    end
	  end
	end

	Then /^the "([^"]*)" field(?: within "([^"]*)")? should contain "([^"]*)"$/ do |field, selector, value|
	  with_scope(selector) do
	    field = find_field(field)
	    field_value = (field.tag_name == 'textarea') ? field.text : field.value
	    if field_value.respond_to? :should
	      field_value.should =~ /#{value}/
	    else
	      assert_match(/#{value}/, field_value)
	    end
	  end
	end

	Then /^the "([^"]*)" field(?: within "([^"]*)")? should not contain "([^"]*)"$/ do |field, selector, value|
	  with_scope(selector) do
	    field = find_field(field)
	    field_value = (field.tag_name == 'textarea') ? field.text : field.value
	    if field_value.respond_to? :should_not
	      field_value.should_not =~ /#{value}/
	    else
	      assert_no_match(/#{value}/, field_value)
	    end
	  end
	end

	Then /^the "([^"]*)" checkbox(?: within "([^"]*)")? should be checked$/ do |label, selector|
	  with_scope(selector) do
	    field_checked = find_field(label)['checked']
	    if field_checked.respond_to? :should
	      field_checked.should be_true
	    else
	      assert field_checked
	    end
	  end
	end

	Then /^the "([^"]*)" checkbox(?: within "([^"]*)")? should not be checked$/ do |label, selector|
	  with_scope(selector) do
	    field_checked = find_field(label)['checked']
	    if field_checked.respond_to? :should
	      field_checked.should be_false
	    else
	      assert !field_checked
	    end
	  end
	end
	 
	Then /^(?:|I )should be on (.+)$/ do |page_name|
	  current_path = URI.parse(current_url).path
	  if current_path.respond_to? :should
	    current_path.should == path_to(page_name)
	  else
	    assert_equal path_to(page_name), current_path
	  end
	end

	Then /^(?:|I )should have the following query string:$/ do |expected_pairs|
	  query = URI.parse(current_url).query
	  actual_params = query ? CGI.parse(query) : {}
	  expected_params = {}
	  expected_pairs.rows_hash.each_pair{|k,v| expected_params[k] = v.split(',')} 
	  
	  if actual_params.respond_to? :should
	    actual_params.should == expected_params
	  else
	    assert_equal expected_params, actual_params
	  end
	end

	Then /^show me the page$/ do
	  save_and_open_page
	end

step12: rails g model articles title:string content:text
step13: rake db:migrate
step14: rake db:test:clone
step15: cucumber features/manage_articles.feature 
step16: rails g controller articles index
step17: in controller file
       
        class ArticlesController < ApplicationController
	  def index
	    @articles = Article.all
	  end

	end

step18: in views articles index.html

        <% for article in @articles %>
	<%=h article.title %>
	<% end %>

step19: cucumber features/manage_articles.feature 



